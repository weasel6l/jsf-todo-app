# JSF → フロントエンド分離に伴う Helidon MP API マイグレーション方針

## 本ルールの適用範囲（重要）

- 本ファイルは **GitHub Copilot のエージェントおよび開発者向けの指針** とする
- 本リポジトリで実装する対象は **Helidon MP による REST API 開発のみ** とする
- フロントエンド（UI実装）は **本リポジトリでは行わない**
- フロントエンドに関する記述は、既存 JSF との対応関係や
  API 設計意図を説明するための **背景情報としてのみ記載** する

---

## 1. 全体方針

- マイグレーションの成功を最優先する
- 設計の美しさより **移行の安全性・分かりやすさ** を重視する
- JSF の画面構造を **画面 + API に写経することを許容** する
- 既存のJSFコードには一切手を加えず、API実装は新規コードとして追加する

---

## 2. アーキテクチャ前提

### クライアント（画面層）
- ブラウザ上で動作する画面クライアント
- 各画面は API と 1 対 1 で対応する

### バックエンド
- REST API（JSON）
- 使用アーキテクチャは Helidon MP
- API は **画面単位で定義** してよい
- 業務ロジックは原則 API 側に置く

---

## 3. API 設計方針（重要）

### 基本ルール

- **1画面 = 1 API（もしくは1画面配下のAPI群）を推奨**
- API 名・URL は画面名と対応させる
- JSF の backing bean 単位で API を作成してよい

### 例

```
/api/order/list
/api/order/detail
/api/order/register
```

- 画面遷移・操作単位で API を切ってよい
- 再利用性より「追跡しやすさ」を優先する

---

## 4. バックエンド実装ルール

### 基本方針

- 本バックエンドは **画面単位 API を前提としたマイグレーション用実装** とする
- 再利用性・汎用性よりも **既存 JSF の挙動再現と追跡しやすさ** を優先する
- 将来のリファクタリングを妨げない範囲で、初期段階の冗長性を許容する
- 実装および変更時のテスト方針は `tdd-java` スキルに従う

---

### DTO に関するルール

- DTO は **画面専用 DTO** を作成してよい
  - 1 画面（または 1 画面配下の API 群）につき 1 DTO を基本とする
- 異なる画面間で DTO を無理に共通化してはならない
- DTO は **API の入出力専用オブジェクト** とする
  - 業務ロジックを含めてはならない
  - 永続化責務を持たせてはならない

---

### Entity に関するルール

- Entity を API のレスポンスとして **直接返してはならない**
- Entity は以下の用途に限定する
  - 永続化（JPA）
  - ドメイン状態の保持
- Entity に以下を実装してはならない
  - 画面表示用の整形ロジック
  - API レスポンス形式を意識したフィールド構成

---

### Controller / Service の責務分離

- Controller（Resource クラス）の責務
  - リクエスト受信
  - DTO ↔ Service 呼び出しの仲介
  - HTTP ステータス・レスポンス制御
- Service の責務
  - 画面単位の業務処理
  - Entity の取得・更新
  - DTO への詰め替え用データ生成

---

### 画面単位 API を前提とした許容事項

- 同じ Entity を使用していても、画面ごとに以下を分けてよい
  - DTO
  - Service
  - バリデーションロジック
- 似た DTO / Service が複数存在することを **問題としない**
- 共通化は「明確な重複コストが発生してから」行う

---

### 命名規約（推奨）

- DTO
  - `{画面名}{操作}Request`
  - `{画面名}{操作}Response`
- Service
  - `{画面名}Service`
- Controller
  - `{画面名}Resource`

---

### 禁止事項（重要）

- Entity をそのまま返却する API 実装
- 画面要件と無関係な DTO の共通化
- 「将来使いそう」という理由だけの抽象化
- Controller への業務ロジック実装

---

### 既存 JSF コードへの操作禁止（重要）

- 既存の JSF Backing Bean を変更すること
- 既存の Model クラスを変更すること
- 既存 JSF コードに対するテストを新規追加・変更すること
- 既存の XHTML・設定ファイルを変更すること

---

### 詳細コーディング規約の参照先

上記は設計方針レベルのルールである。以下の詳細規約は各スキルを権威情報とする

| 規約カテゴリ | 参照スキル |
|---|---|
| コーディング規約・Javadoc 規約・Lombok・DI・バリデーション・OpenAPI アノテーション | `api-implementation` |
| TDD サイクル・テスト構造・Given-When-Then | `tdd-java` |
| コミット粒度・メッセージ形式・コミット除外ファイル | `git-commit` |

---

## 5. フロントエンド実装ルール（参考情報）

※ 本章は、API 設計時に「画面側からどのように利用されるか」を
理解するための **参考情報** とする

※ 本リポジトリではフロントエンド実装は行わない

- 1画面 = 1画面クライアント単位で実装する
- API 呼び出しは画面単位で行ってよい
- 状態管理は最小限から始める
- 画面単位で完結する状態はローカルに保持する

---

## 6. JSF 機能の責務変換ルール

本セクションでは **JSF 固有機能を API 実装へ移行する際の責務の置き換え方** を定義する

---

### 対応関係一覧（責務レベル）

| JSF 機能 | API 側での扱い |
|---|---|
| backing bean | 画面単位 API（Controller）＋ Service |
| commandButton | 画面操作に対応する API エンドポイント |
| SessionScoped Bean | サーバー側状態管理またはステートレス設計 |

---

### backing bean の扱い

- JSF backing bean は以下に分離して実装する
  - Controller：画面単位 API のエンドポイント定義
  - Service：画面単位の業務処理
- backing bean に含まれていた業務ロジックは Service に集約する
- 画面遷移制御に関するロジックは API 側には持たせない

---

### commandButton の扱い

- JSF の commandButton は
  **ユーザー操作に対応する API 呼び出し**として扱う
- 原則として「1 操作 = 1 API エンドポイント」で定義してよい
- 移行フェーズでは、再利用性よりも
  既存 JSF 画面との対応関係の分かりやすさを優先する

---

## 7. 画面遷移・URL 設計

- JSF 画面とマイグレーション後の画面は、設計上 1 対 1 対応を前提とする
- 既存の画面遷移フローを尊重する
- リロード可能であることを必須とする

---

## 8. 判断に迷った場合の優先順位

1. 既存 JSF の挙動を壊さない
2. 画面と API の対応が直感的である
3. 移行作業者が理解しやすい
